#to install the anytree module run: $ pip install anytree
from anytree import Node, RenderTree

#function for new node
def addT( name,par = None ):
		#case node doesn't have a parent
		if par == None: aux = Node( name,parent = None )
		#other case; "has a parent"
		else: aux = Node( name,parent = par )
		#return aux
		return aux

#function to print Tree with givin root
def printT( root ):
	for pre,fill,node in RenderTree( root ):
		print( "%s%s" % ( pre,node.name[ 0 ] ) )

#function to slice word with a givin position
def slice( string,i ):
	return string[ i: ]

#function to receive a list of tokens
def parse_program( lexer ):
	#case the list isn't empyt and calls function parse_function 
	if len( lexer ) > 0 and parse_function( lexer ):
		#saves node generated by parse_function ("Function")
		p = parse_function( lexer )
		#creates node "Program"
		a = addT( [ "Program",1 ] )
		#sets node generated by parse_function ( node "Function") as a child for node "Program"
		p.parent = a
		return a
	#print error for other case	
	else:
		print ( "Syntax error" )

#function to parse function
def parse_function( fun ):
	if fun[ 0 ][ 0 ] == "INT K":
		if fun[ 1 ][ 0 ] == "IDENTIFIER":
			if fun[ 2 ][ 0 ] == "OPEN PA":
				if fun[ 3 ][ 0 ] == "CLOSE PA":
					if fun[ 4 ][ 0 ] == "OPEN BR":
						#calls parse_statement to see if it can create a node
						if parse_statement( slice( fun,5 ) ):
							#saves in variable, "a" has node "Return"
							a,b = parse_statement( slice( fun,5 ) )
							if b[ 0 ][ 0 ] == "CLOSE BR":
								#creates a node "Function"
								main = addT( [ "Function",fun ] )
								#sets parse_statement (node "Return") as a child for node "Function"
								a.parent = main
								return main

#function to parse statements
def parse_statement( st ):
	#needs to have a return token
	if st[ 0 ][ 0 ] == "RETURN K":
		#calls function to parse expression
		if parse_exp( slice( st,1 ) ):
			#saves it in variables, "a" has node "Cte"
			a,b = parse_exp( slice( st,1 ) )
			if b[ 0 ][ 0 ] == "SEMIC":
				#creates node "Return"
				re = addT( [ "Return",st ] )
				#set parse_expression (node "Cte") as a child for node "Return"
				a.parent = re
				return re,slice( b,1 )
			
#function to parse expressions
def parse_exp( ex ):
	#needs to be a type int
	if ex[ 0 ][ 0 ] == "INT":
		#creates node "Cte" with number and list of tokens in it
		cte = addT( [ ex[ 0 ][ 1 ],ex ] )
		return cte, slice( ex,1 )
